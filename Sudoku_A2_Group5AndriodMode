int canvas_width  = 500;
int canvas_height = 900;
int grid_size     = 9;
int grid_top      = 125;
int grid_bottom   = 625;
int selectorH     = 50;
int xflowchart = 650;
int yflowchart = 50;
int cell_w, cell_h, cellSelectorW, selectorTop;
int[][] num        = new int[grid_size][grid_size];
boolean[][] isError = new boolean[grid_size][grid_size];
int[][] solution   = new int[grid_size][grid_size];

int[] clicked_cell = null;
Integer selectedNumber = null;

boolean showCorrect = false;

// Buttons
int btnW = 160, btnH = 45;
int resetX = 60, resetY;
int showX, showY;

void settings() {
  size(1000, canvas_height);
}

void setup() {
  cell_w = canvas_width / grid_size;
  cell_h = (grid_bottom - grid_top) / grid_size;
  cellSelectorW = canvas_width / grid_size;
  selectorTop = grid_bottom + 20;

  resetY = grid_bottom + 100;
  showY  = grid_bottom + 100;
  showX  = 280;

  generatePuzzle();
}

void draw() {
  background(255);
  //game section
  drawCorrect();
  draw_table();
  if (clicked_cell != null) {
    draw_rect_in_cell(clicked_cell[0], clicked_cell[1],225,225,225); // draw highlight before digits
  }
  drawNumbers();
  drawErrors();
  drawNumberSelector();
  drawButtons();
  
  //flowchart section
  int y1 = start_stop_type(xflowchart, yflowchart, 100, "START");
  drawArrow(xflowchart, yflowchart+25, y1-50);
  
  int y2 = process_type(xflowchart, y1, 100, "Initialize Grid");
  drawArrow(xflowchart, y1+50, y2-40);
  
  int y3 = process_type(xflowchart, y2, 110, "User Interaction");
  drawArrow(xflowchart, y2+55, y3-50);
  
  int y4 = decision_type(xflowchart, y3, 100, "Is Solved?");
  text_box(xflowchart + 25,y4-75,1,"TRUE");
  drawArrowHorizontal(xflowchart + 100, xflowchart + 200, y3);
  text_box(xflowchart + 120,y3-20,1,"FALSE");
  drawArrow(xflowchart+200, y3, y4-50);
  drawArrow(xflowchart, y3+50, y4-50);
  
  int y5 = process_type(xflowchart, y4, 100, "Show Result");
  drawArrow(xflowchart, y4+50, y5-70);
  drawArrowHorizontal(xflowchart, xflowchart + 200, y5-70);
  int y5alt = process_type(xflowchart+200, y4, 100, "Show Mistake");
  drawArrow(xflowchart+200, y4+50, y5-50);
  
  start_stop_type(xflowchart+200, y5alt-25, 100, "END");
}

void draw_table() {
  strokeWeight(5);
  stroke(0);
  line(0, grid_top, canvas_width, grid_top);
  line(0, grid_bottom, canvas_width, grid_bottom);
  for (int i = 1; i < grid_size; i++) {
    int x = i * cell_w;
    int y = grid_top + i * cell_h;
    strokeWeight(i % 3 == 0 ? 3 : 1);
    line(x, grid_top, x, grid_bottom);
    line(0, y, canvas_width, y);
  }
  strokeWeight(5);
  line(canvas_width-1,grid_top,canvas_width-1,grid_bottom);
}

void drawNumbers() {
  textSize(24);
  textAlign(CENTER, CENTER);
  for (int r = 0; r < grid_size; r++) {
    for (int c = 0; c < grid_size; c++) {
      int n = num[r][c];
      if (n != 0) {
        int x = c * cell_w + cell_w/2;
        int y = grid_top + r * cell_h + cell_h/2;
        if (showCorrect && n == solution[r][c]) {
          fill(6, 2, 112);
           // green for correct
        } else {
          fill(0); // black for normal
        }
        text(n, x, y);
      }
    }
  }
}

void drawCorrect(){
for (int r = 0; r < grid_size; r++) {
    for (int c = 0; c < grid_size; c++) {
      int n = num[r][c];
      if (n != 0) {
        if (n == solution[r][c]) {
          draw_rect_in_cell(r, c,170, 231, 146);
          }
      }
    }
  }
}

void drawErrors() {
  noFill();
  strokeWeight(3);
  for (int r = 0; r < grid_size; r++) {
    for (int c = 0; c < grid_size; c++) {
      if (num[r][c] == 0) continue;
      
      if (isError[r][c]) {
        int x = c * cell_w;
        int y = grid_top + r * cell_h;
        stroke(255,178,102);
        rect(x + 2, y + 2, cell_w - 4, cell_h - 4);
      }

      boolean wrong = false;
      if (solution != null && solution[r][c] != 0) {
        wrong = (num[r][c] != solution[r][c]);
      } else {
        // fallback: detect conflicts by row, column, and 3x3 block
        int v = num[r][c];
        for (int i = 0; i < grid_size && !wrong; i++) {
          if (i != c && num[r][i] == v) wrong = true;
          if (i != r && num[i][c] == v) wrong = true;
        }
        int sr = (r / 3) * 3, sc = (c / 3) * 3;
        for (int rr = sr; rr < sr + 3 && !wrong; rr++) {
          for (int cc = sc; cc < sc + 3 && !wrong; cc++) {
            if ((rr != r || cc != c) && num[rr][cc] == v) wrong = true;
          }
        }
      }

      if (wrong) {
        stroke(255,0,0);
        int x = c * cell_w;
        int y = grid_top + r * cell_h;
        rect(x + 2, y + 2, cell_w - 4, cell_h - 4);
      }
    }
  }
  noStroke();
}

void markRowColConflicts(int r, int c) {
  int v = num[r][c];
  if (v == 0) return;

  // Clear previous errors
  for (int i = 0; i < grid_size; i++) {
    for (int j = 0; j < grid_size; j++) {
      isError[i][j] = false;
    }
  }

  // Check row
  for (int i = 0; i < grid_size; i++) {
    if (i != c && num[r][i] == v) {
      isError[r][i] = true;
      isError[r][c] = true;
    }
  }

  // Check column
  for (int i = 0; i < grid_size; i++) {
    if (i != r && num[i][c] == v) {
      isError[i][c] = true;
      isError[r][c] = true;
    }
  }
}


void drawNumberSelector() {
  for (int i = 0; i < grid_size; i++) {
    int x = i * cellSelectorW;
    int y = selectorTop;
    fill(selectedNumber != null && selectedNumber == i+1 ? 200 : 240);
    stroke(0);
    rect(x, y, cellSelectorW, selectorH);
    fill(0);
    textSize(24);
    textAlign(CENTER, CENTER);
    text(i+1, x + cellSelectorW/2, y + selectorH/2);
  }
}

void drawButtons() {
  fill(230);
  stroke(0);
  rect(resetX, resetY, btnW, btnH, 10);
  fill(0);
  textAlign(CENTER, CENTER);
  textSize(16);
  text("Reset Puzzle", resetX + btnW/2, resetY + btnH/2);

}

boolean inBox(int mx,int my,int x,int y,int x2,int y2){
  return mx>x && mx<x2 && my>y && my<y2;
}

void mousePressed() {
  // Select cell
  for(int r=0;r<grid_size;r++){
    for(int c=0;c<grid_size;c++){
      int x1=c*cell_w;
      int y1=grid_top+r*cell_h;
      int x2=x1+cell_w;
      int y2=y1+cell_h;
      if(inBox(mouseX,mouseY,x1,y1,x2,y2)){
        clicked_cell=new int[]{r,c};
        return;
      }
    }
  }

  // Select number
  if(mouseY>=selectorTop && mouseY<=selectorTop+selectorH){
    for(int i=0;i<grid_size;i++){
      int x=i*cellSelectorW;
      if(mouseX>=x && mouseX<=x+cellSelectorW){
        selectedNumber=i+1;
        if (clicked_cell != null) {
            int r = clicked_cell[0], c = clicked_cell[1];
            num[r][c] = selectedNumber;
            markRowColConflicts(r, c); // ← this highlights all matching numbers in row/col
        }
        return;
      }
    }
  }
  // Reset button
  if(inBox(mouseX,mouseY,resetX,resetY,resetX+btnW,resetY+btnH)){
    generatePuzzle();
    clicked_cell=null;
    selectedNumber=null;
    showCorrect=false;
    for(int i=0;i<grid_size;i++)
      for(int j=0;j<grid_size;j++)
        isError[i][j]=false;
    return;
  }
}

void keyPressed(){
  if(clicked_cell!=null){
    int r=clicked_cell[0], c=clicked_cell[1];
    if(key>='1' && key<='9') num[r][c]=key-'0';
    else if(key=='0' || keyCode==BACKSPACE || keyCode==DELETE) num[r][c]=0;
  }
  if(key=='r' || key=='R'){
    generatePuzzle();
    clicked_cell=null;
    selectedNumber=null;
    showCorrect=false;
    for(int i=0;i<grid_size;i++)
      for(int j=0;j<grid_size;j++)
        isError[i][j]=false;
  }
}

int[][] generateSolution(){
  int[][] b=new int[grid_size][grid_size];
  solveBoard(b);
  return b;
}

boolean solveBoard(int[][] b){
  for(int r=0;r<grid_size;r++){
    for(int c=0;c<grid_size;c++){
      if(b[r][c]==0){
        int[] pool=shuffleNumbers();
        for(int numTry:pool){
          if(isValid(b,r,c,numTry)){
            b[r][c]=numTry;
            if(solveBoard(b)) return true;
            b[r][c]=0;
          }
        }
        return false;
      }
    }
  }
  return true;
}

boolean isValid(int[][] b,int row,int col,int numTry){
  for(int i=0;i<grid_size;i++)
    if(b[row][i]==numTry || b[i][col]==numTry) return false;
  int sr=(row/3)*3, sc=(col/3)*3;
  for(int r=sr;r<sr+3;r++)
    for(int c=sc;c<sc+3;c++)
      if(b[r][c]==numTry) return false;
  return true;
}

int[] shuffleNumbers(){
  int[] a=new int[9];
  for(int i=0;i<9;i++) a[i]=i+1;
  for(int i=8;i>0;i--){
    int j=int(random(i+1));
    int t=a[i]; a[i]=a[j]; a[j]=t;
  }
  return a;
}

void generatePuzzle(){
  solution=generateSolution();
  for(int r=0;r<grid_size;r++){
    for(int c=0;c<grid_size;c++){
      if(random(1)>0.5) num[r][c]=solution[r][c];
      else num[r][c]=0;
      isError[r][c]=false;
    }
  }
}

void checkSolution(){
  boolean allCorrect=true;
  for(int r=0;r<grid_size;r++){
    for(int c=0;c<grid_size;c++){
      if(num[r][c]!=0 && num[r][c]!=solution[r][c]){
        isError[r][c]=true;
        allCorrect=false;
      }else{
        isError[r][c]=false;
      }
    }
  }
  if(allCorrect){
    println("All correct!");
    generatePuzzle();
    clicked_cell=null;
    selectedNumber=null;
    showCorrect=false; 
  }
  else println("Mistakes highlighted in red.");
}

void draw_rect_in_cell(int row,int col,int r,int g ,int b){
  noFill();
  fill(r, g, b);
  strokeWeight(3);
  float x=col*cell_w;
  float y=grid_top+row*cell_h;
  rect(x,y,cell_w,cell_h);
  noStroke();
}

int process_type(int posx, int posy, int size, String word) {
  fill(255);
  stroke(0);
  strokeWeight(2);
  rect(posx - size / 2, posy - size / 2, size, size); // centered box

  fill(0);
  textAlign(CENTER, CENTER);
  textSize(16);
  text(word, posx, posy);

  return posy + size / 2 + 100; // bottom Y + spacing
}

int decision_type(int posx, int posy, int size, String word) {
  fill(255);
  stroke(0);
  strokeWeight(2);
  quad(
    posx, posy - size / 2,         // top
    posx + size, posy,             // right
    posx, posy + size / 2,         // bottom
    posx - size, posy              // left
  );

  fill(0);
  textAlign(CENTER, CENTER);
  textSize(16);
  text(word, posx, posy);

  return posy + size / 2 + 100; // bottom Y + spacing
}

int start_stop_type(int posx, int posy, int size, String word) {
  fill(255);
  stroke(0);
  strokeWeight(2);
  ellipse(posx, posy, size, size / 2); // horizontal ellipse

  fill(0);
  textAlign(CENTER, CENTER);
  textSize(16);
  text(word, posx, posy);

  return posy + size / 4 + 100; // bottom Y + spacing
}

void drawArrow(int x, int y1, int y2) {
  int arrowGap = 10;
  stroke(0);
  strokeWeight(2);
  line(x, y1, x, y2 - arrowGap); // stop before the next shape

  fill(0);
  triangle(
    x - 6, y2 - arrowGap,
    x + 6, y2 - arrowGap,
    x,     y2
  );
}

void text_box(int posx, int posy, int size, String word) {
  fill(255);
  stroke(255);
  rect(posx - size / 2, posy - size / 2, size, size); // centered box

  fill(0);
  textAlign(CENTER, CENTER);
  textSize(16);
  text(word, posx, posy);

}

void drawArrowHorizontal(int x1, int x2, int y) {
  stroke(0);
  strokeWeight(2);
  line(x1, y, x2 - 10, y);
  fill(0);
  triangle(x2 - 10, y - 6, x2 - 10, y + 6, x2, y);
}
